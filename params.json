{"name":"TestTools for PHPUnit","tagline":"Easy dependency injection and self-initializing fixtures","body":"**The goal of this project is to increase testing productivity by leveraging the power of dependency injection and self-initializing fixtures for PHPUnit tests.**\r\n\r\nThe tools contain two parts: An integrated DI container for **easy dependency injection** using YAML config files (instead of mocking every single class dependency or doing the dependency injection manually) and **self-initializing fixtures** to replace storage backends such as SQL databases or REST services with record and playback fixtures. \r\n\r\nHere’s an example of a test case built with TestTools – note the **setUp()** method, which get’s the ready-to-use object from the dependency injection container:\r\n\r\n    use TestTools\\TestCase\\UnitTestCase;\r\n\r\n    class FooTest extends UnitTestCase\r\n    {\r\n        protected $foo;\r\n\r\n        public function setUp()\r\n        {\r\n            $this->foo = $this->get('foo');\r\n        }\r\n\r\n        public function testBar()\r\n        {\r\n            $result = $this->foo->bar('Pi', 2);\r\n            $this->assertEquals(3.14, $result);\r\n        }\r\n    }\r\n\r\nYou’ll get **fresh instances** in every test, so there is **no global state** that could harm our tests. From that point of view, they run in isolation. The compiled service definitions in the container are reused however for performance reasons.\r\n\r\nThis approach let’s you create tests **much faster**, you’ll get a **higher code coverage** and need to invest **less effort in maintenance**. \r\n\r\nTo define services, simply create a `config.yml` (optionally `config.local.yml` for local modifications) in your base test directory.\r\n\r\nTestTools can be used to test any application, framework or library, just like `PHPUnit_Framework_TestCase`. It is not limited to the Symfony ecosystem. The Symfony Components DI container was chosen, because of it's easy to understand container configuration in YAML.\r\n\r\nSelf-initializing Fixtures\r\n--------------------------\r\nThe concept of [self-initializing fakes](http://martinfowler.com/bliki/SelfInitializingFake.html) as test doubles can be applied to all types of external data stores (databases) and services like SOAP or REST APIs.\r\n\r\nTo cover some of the most common use cases, **Doctrine DBAL** (SQL), **Guzzle** and **Buzz** (HTTP) are supported out of the box.\r\n \r\n`SelfInitializingFixtureTrait` enables existing classes to work with file based fixtures (record and playback):\r\n\r\n    use TestTools\\Fixture\\SelfInitializingFixtureTrait;\r\n\r\n    class Foo extends SomeBaseClass\r\n    {\r\n        use SelfInitializingFixtureTrait;\r\n\r\n        public function bar($name, $type, array $baz = array())\r\n        {\r\n            return $this->callWithFixtures('bar', func_get_args());\r\n        }\r\n    }\r\n\r\nClassic vs mockist style of unit testing\r\n----------------------------------------\r\n\r\nThese tools **simplify writing unit tests using real objects and test doubles** via dependency injection, so some developers might be concerned that the resulting tests are not *true* unit tests as **class dependencies are not mocked by default**. Mocking is creating objects that simulate the behaviour of real objects. These apparently conflicting approaches are referred to as the **classic and mockist styles of unit testing**:\r\n\r\n\"The **classical TDD style** is to use **real objects** if possible and a double if it's awkward to use the real thing. So a classical TDDer would use a real warehouse and a double for the mail service. The kind of double doesn't really matter that much.\r\n\r\nA **mockist TDD** practitioner, however, will always use a mock for any object with interesting behavior. In this case for both the warehouse and the mail service.\" -- [Martin Fowler](http://martinfowler.com/articles/mocksArentStubs.html)\r\n\r\n[Mocks and test doubles](http://martinfowler.com/bliki/TestDouble.html) are required to be able to test sometimes, but since **creating and maintaining mocks can be a time-consuming endeavour**, it makes sense to avoid their widespread usage and prefer using real objects instead. They do no harm - quite the contrary: You can instantly see, how the real objects interact with each other instead of waiting for functional tests. Actually, the need for excessive mocking is an indicator for bad software design.\r\n\r\nIn theory, the mockist style can be a bit **more precise** when it comes to finding a broken line of code, because all classes are tested in complete isolation. In practice, **classic unit tests will also provide you with a stack trace** that points you to the right line of code:\r\n\r\n\"We didn't find it difficult to track down the actual fault, even if it caused neighboring tests to fail. **So we felt isolation wasn't an issue in practice**.\" -- [Martin Fowler](http://martinfowler.com/bliki/UnitTest.html)\r\n\r\nIn the worst case, more than one test case fails, if just one class or function is broken – will give you even more information about the issue and allows to find and fix affected code easily.\r\n\r\nEven code that depends on databases or Web services, can be easily tested using **self-initializing fixtures** instead of hand-written mocks. The only thing they can not properly simulate is state, but robust unit tests shouldn't depend on state anyways. If you want to test state, use [functional tests of the user interface or API](http://martinfowler.com/bliki/TestPyramid.html) instead.\r\n\r\nComposer\r\n--------\r\n\r\nIf you are using composer, simply add \"lastzero/test-tools\" to your composer.json file and run `composer update`:\r\n\r\n    \"require-dev\": {\r\n        \"lastzero/test-tools\": \"~2.0\"\r\n    }\r\n\r\nFor PHP 5.4 compatibility, use version \"~1.2\".","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}